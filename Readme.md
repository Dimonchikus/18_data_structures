Тести BBS:

| Dataset Size (n) | Insert Time (ns) | Search Time (ns) | Delete Time (ns) |
|------------------|------------------|------------------|------------------|
| 1,000            | 100              | 91               | 111              |
| 2,000            | 122              | 116              | 129              |
| 4,000            | 146              | 137              | 157              |
| 8,000            | 161              | 152              | 170              |
| 16,000           | 179              | 174              | 189              |
| 32,000           | 204              | 192              | 211              |
| 64,000           | 221              | 209              | 228              |
| 128,000          | 240              | 232              | 257              |
| 256,000          | 264              | 251              | 289              |
| 512,000          | 281              | 267              | 296              |


### Визначаємо, коли counting sort перестає ок працювати

**Складність counting sort:** Часова складність counting sort дорівнює O(n + k), де:

• n – кількість елементів для сортування.
• k – діапазон вхідних значень (максимальне значення – мінімальне значення).

**Проблеми продуктивності:**

• Великий діапазон: якщо k значно більше за n, O(n + k) часова складність може стати неефективною.  
• Використання пам’яті: counting sort вимагає додаткової памʼяті, пропорційної діапазону k. Велике k призводить до великого споживання пам'яті.

**Критерії неефективності:**

• Коли k >> n: Алгоритм стає неефективним, якщо діапазон вхідних даних великий порівняно з кількістю елементів.  
• float(не цілі числа) ключі: counting sort не підходить для сортування нецілочисельних даних або даних, які не можна зіставити з невід’ємними цілими числами.

**приклад:**

Припустимо, у вас є масив із 100 елементів (n = 100), але значення коливаються від 1 до 1 000 000 (k = 1 000 000). Тут k набагато більше за n, що робить counting sort неефективним як з точки зору часу, так і простору.

**Які ж є альтернативи йому:**

• comparison sorts: такі алгоритми, як «merge sort» або «quick sort», займають час O(n log n) незалежно від діапазону вхідних даних.  
• radix sort: для великих діапазонів radix sort може бути більш ефективною, ніж counting sort, особливо при роботі з цілими числами.

**висновок:**

counting sort є найбільш ефективним, коли:

• Діапазон k не значно більший за кількість елементів n.  
• Дані складаються з цілих чисел у обмеженому діапазоні.

Він погано працює, якщо ці умови не виконуються через збільшення time and space складності.